<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MTG Mobile - Combat Edition</title>
    <style>
        :root { --bg: #121212; --card-bg: #2a2a2e; --text: #e0e0e0; --accent: #3a7bd5; --danger: #cc0000; }
        * { box-sizing: border-box; }
        body { font-family: system-ui, -apple-system, sans-serif; background: var(--bg); color: var(--text); margin: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        
        /* Header: Fixed */
        #phase-bar { flex-shrink: 0; background: #000; display: flex; justify-content: space-around; padding: 12px 5px; font-size: 10px; font-weight: bold; border-bottom: 2px solid var(--accent); z-index: 10; }
        .phase-item { opacity: 0.3; transition: 0.3s; }
        .phase-item.active { opacity: 1; color: #00d4ff; text-shadow: 0 0 5px #00d4ff; }

        /* Middle: Scrollable Battlefield */
        #game-scroll-area { flex-grow: 1; overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 15px; -webkit-overflow-scrolling: touch; }
        .zone { display: flex; gap: 10px; overflow-x: auto; padding: 10px 0; min-height: 120px; align-items: center; border-bottom: 1px solid #333; }
        .section-label { font-size: 11px; text-transform: uppercase; color: #666; letter-spacing: 1px; }

        /* Card Styling */
        .card { 
            width: 85px; height: 120px; background: var(--card-bg); border: 2px solid #555; border-radius: 6px; 
            flex-shrink: 0; display: flex; flex-direction: column; padding: 6px; position: relative; font-size: 10px; 
        }
        .card.tapped { transform: rotate(8deg); filter: brightness(0.6); border-color: var(--danger); }
        .card.attacking { border-color: #ffaa00; box-shadow: 0 0 10px #ffaa00; }
        .card.blocking { border-color: #00ff00; }
        .card-header { display: flex; justify-content: space-between; font-weight: bold; border-bottom: 1px solid #444; margin-bottom: 4px; padding-bottom: 2px; }
        .card-cost { color: #aaa; }
        .card-desc { font-style: italic; color: #999; flex: 1; line-height: 1.2; font-size: 9px; margin-top: 4px; overflow: hidden; }
        .card-stats { text-align: right; font-weight: bold; font-size: 12px; color: #fff; }
        .land-card { background: #1e2b1e; border-color: #3e5b3e; }
        
        /* Footer: Fixed Controls */
        #ui-footer { flex-shrink: 0; background: #1a1a1a; border-top: 1px solid #333; z-index: 10; }
        .stats-row { display: flex; justify-content: space-between; padding: 8px 15px; font-size: 14px; background: #000; border-bottom: 1px solid #222; }
        #log { font-size: 11px; height: 45px; overflow-y: auto; background: #000; color: #4af; padding: 5px 15px; }
        .controls { padding: 12px; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        button { padding: 14px; border-radius: 8px; border: none; font-weight: bold; font-size: 14px; background: var(--accent); color: white; transition: 0.2s; }
        button:active { filter: brightness(1.2); transform: translateY(1px); }
        button:disabled { background: #333; color: #666; }
        #btn-next { background: #28a745; }
    </style>
</head>
<body>

<div id="phase-bar">
    <span id="p-MAIN1" class="phase-item">MAIN 1</span>
    <span id="p-ATTACK" class="phase-item">ATTACK</span>
    <span id="p-BLOCK" class="phase-item">BLOCK</span>
    <span id="p-MAIN2" class="phase-item">MAIN 2</span>
</div>

<div id="game-scroll-area">
    <div class="section-label">AI Battlefield (HP: <span id="ai-hp-val">20</span>)</div>
    <div class="zone" id="ai-field"></div>
    
    <div class="section-label">Your Battlefield (HP: <span id="p-hp-val">20</span>)</div>
    <div class="zone" id="player-field"></div>
    
    <div class="section-label">Your Hand</div>
    <div class="zone" id="player-hand"></div>
    <div style="height: 20px;"></div> </div>

<div id="ui-footer">
    <div id="log">> Game Started. Your Turn.</div>
    <div class="stats-row">
        <span>MANA: <b id="mana-val">0</b></span>
        <span>CARDS: <b id="hand-val">0</b></span>
    </div>
    <div class="controls">
        <button id="btn-land" onclick="playLandAction()">Play Land</button>
        <button id="btn-next" onclick="nextPhase()">Next Phase</button>
    </div>
</div>

<script>
const PHASES = ['MAIN1', 'ATTACK', 'BLOCK', 'MAIN2'];
let state = {
    p_hp: 20, p_hand: [], p_field: [], p_mana: 0, p_landPlayed: false,
    ai_hp: 20, ai_hand: [], ai_field: [], ai_mana: 0,
    phaseIdx: 0, isAITurn: false,
    attackers: [], blockers: [] // IDs of cards involved in combat
};

const DECK = [
    { name: "Forest", type: "land", cost: 0, desc: "{T}: Add 1 Mana" },
    { name: "Squire", type: "creature", cost: 1, p: 1, t: 1, desc: "A loyal recruit." },
    { name: "Knight", type: "creature", cost: 2, p: 2, t: 2, desc: "Brave and bold." },
    { name: "Grizzly", type: "creature", cost: 3, p: 3, t: 3, desc: "Hungry and wild." }
];

function createCard(proto) { return { ...proto, id: Math.random(), tapped: false, sickness: true }; }

function init() {
    for(let i=0; i<7; i++) {
        state.p_hand.push(createCard(DECK[Math.floor(Math.random() * 2)]));
        state.ai_hand.push(createCard(DECK[Math.floor(Math.random() * 2)]));
    }
    updateUI();
}

function updateUI() {
    document.getElementById('p-hp-val').innerText = state.p_hp;
    document.getElementById('ai-hp-val').innerText = state.ai_hp;
    document.getElementById('mana-val').innerText = state.p_mana;
    document.getElementById('hand-val').innerText = state.p_hand.length;

    document.querySelectorAll('.phase-item').forEach(el => el.classList.remove('active'));
    if (!state.isAITurn) document.getElementById('p-' + PHASES[state.phaseIdx]).classList.add('active');

    renderZone('player-hand', state.p_hand, 'hand');
    renderZone('player-field', state.p_field, 'field');
    renderZone('ai-field', state.ai_field, 'ai');
    
    document.getElementById('btn-land').disabled = state.p_landPlayed || state.isAITurn || state.phaseIdx !== 0;
    document.getElementById('btn-next').innerText = (state.phaseIdx === 3) ? "End Turn" : "Next Phase";
}

function renderZone(id, cards, type) {
    const el = document.getElementById(id);
    el.innerHTML = '';
    cards.forEach(card => {
        const div = document.createElement('div');
        const isAttacking = state.attackers.includes(card.id);
        const isBlocking = state.blockers.find(b => b.blockerId === card.id);
        
        div.className = `card ${card.type === 'land' ? 'land-card' : ''} ${card.tapped ? 'tapped' : ''} ${isAttacking ? 'attacking' : ''} ${isBlocking ? 'blocking' : ''}`;
        div.innerHTML = `
            <div class="card-header"><span>${card.name}</span><span class="card-cost">${card.type === 'creature' ? card.cost : ''}</span></div>
            <div class="card-desc">${card.desc}</div>
            ${card.type === 'creature' ? `<div class="card-stats">${card.p}/${card.t}</div>` : ''}
        `;
        
        div.onclick = () => handleCardClick(card, type);
        el.appendChild(div);
    });
}

function handleCardClick(card, zoneType) {
    if (state.isAITurn) return;
    
    if (zoneType === 'hand') {
        if (card.type === 'land' && !state.p_landPlayed && state.phaseIdx === 0) {
            state.p_field.push(card);
            state.p_hand = state.p_hand.filter(c => c.id !== card.id);
            state.p_landPlayed = true;
            log("Played Land.");
        } else if (card.type === 'creature' && state.p_mana >= card.cost && state.phaseIdx === 0) {
            state.p_mana -= card.cost;
            state.p_field.push(card);
            state.p_hand = state.p_hand.filter(c => c.id !== card.id);
            log(`Cast ${card.name}.`);
        }
    } else if (zoneType === 'field') {
        if (card.type === 'land') {
            if (!card.tapped) { card.tapped = true; state.p_mana++; log("Mana +1"); }
        } else if (card.type === 'creature' && state.phaseIdx === 1) { // ATTACK PHASE
            if (!card.sickness && !card.tapped) {
                if (state.attackers.includes(card.id)) {
                    state.attackers = state.attackers.filter(id => id !== card.id);
                } else {
                    state.attackers.push(card.id);
                }
            }
        } else if (card.type === 'creature' && state.phaseIdx === 2 && state.isAITurn) { // Should not happen in player turn
             // Player blocking logic handled when AI attacks
        }
    }
    updateUI();
}

function log(msg) {
    const l = document.getElementById('log');
    l.innerHTML = `> ${msg}<br>${l.innerHTML}`;
}

async function nextPhase() {
    if (state.phaseIdx === 1) { // Finish Attack -> Move to Block
        state.phaseIdx = 2;
        log("AI is choosing blockers...");
        await new Promise(r => setTimeout(r, 600));
        resolveCombat(true); // Player is attacking
    } else if (state.phaseIdx === 3) {
        startAITurn();
        return;
    } else {
        state.phaseIdx++;
    }
    updateUI();
}

function resolveCombat(playerIsAttacking) {
    if (playerIsAttacking) {
        let totalDmg = 0;
        state.attackers.forEach(id => {
            let c = state.p_field.find(card => card.id === id);
            if (c) {
                c.tapped = true;
                // AI Block Logic: Simple 50% chance to block if it has creatures
                let possibleBlocker = state.ai_field.find(aiC => aiC.type === 'creature' && !aiC.tapped);
                if (possibleBlocker) {
                    log(`AI blocked ${c.name} with ${possibleBlocker.name}`);
                    possibleBlocker.tapped = true;
                    // In this lite version, creatures just stop damage. 
                } else {
                    totalDmg += c.p;
                }
            }
        });
        state.ai_hp -= totalDmg;
        log(`You dealt ${totalDmg} damage!`);
        state.attackers = [];
    }
}

async function startAITurn() {
    state.isAITurn = true;
    state.phaseIdx = 0;
    updateUI();
    
    log("AI Turn Starting...");
    await new Promise(r => setTimeout(r, 600));
    
    // AI Draw & Untap
    state.ai_hand.push(createCard(DECK[Math.floor(Math.random() * DECK.length)]));
    state.ai_field.forEach(c => { c.tapped = false; c.sickness = false; });
    
    // AI Play Card
    let m = state.ai_field.filter(c => c.type === 'land').length;
    let playIdx = state.ai_hand.findIndex(c => c.type === 'creature' && c.cost <= m);
    if(playIdx > -1) state.ai_field.push(state.ai_hand.splice(playIdx, 1)[0]);

    // AI Declare Attackers
    let aiAttackers = state.ai_field.filter(c => c.type === 'creature' && !c.sickness);
    if (aiAttackers.length > 0) {
        log("AI is attacking! Choose blockers?");
        state.phaseIdx = 2; // Move to Block Phase
        // Simplified auto-resolve for AI for now, but the structure is there!
        let dmg = 0;
        aiAttackers.forEach(c => {
            c.tapped = true;
            dmg += c.p;
        });
        state.p_hp -= dmg;
        log(`AI attacked for ${dmg}!`);
    }

    await new Promise(r => setTimeout(r, 600));
    
    // Cleanup & Player Turn Start
    state.isAITurn = false;
    state.p_landPlayed = false;
    state.phaseIdx = 0;
    state.p_mana = 0;
    state.p_field.forEach(c => { c.tapped = false; c.sickness = false; });
    state.p_hand.push(createCard(DECK[Math.floor(Math.random() * DECK.length)]));
    log("Your Turn. Untap & Draw.");
    updateUI();
}

init();
</script>
</body>
</html>
